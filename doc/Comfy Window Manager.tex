\documentclass[titlepage]{article}

\usepackage[utf8]{inputenc}
\usepackage{scrextend}
\usepackage[bottom]{footmisc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}

\title{Comfy: Gestionnaire de fenêtres en tuiles}
\author{Daniel-Junior Dubé et Félix Chabot}
\date{Session d'automne 2018}

\graphicspath{ {./images/} }

\lstset{frame=single,numbers=left,inputpath=./sources}

\begin{document}
\maketitle

\renewcommand{\contentsname}{Table des matières}
\tableofcontents
\newpage

\section{Introduction}
\par
\bigskip
En tant qu'enthousiastes des systèmes d'exploitation GNU/Linux depuis quel-ques années, nous avons pu observer l’engouement de la communauté envers les gestionnaires des fenêtres en tuiles\footnote{https://en.wikipedia.org/w/index.php?title=Tiling\_window\_manager}. En effet, ces gestionnaires permettent une plus grande flexibilité pour la personnalisation de l’expérience utilisateur que les environnements de bureau populaire tel que \textit{Gnome}, \textit{KDE} et \textit{Xfce} tout en étant plus léger sur l’utilisation des ressources matérielles. Tout comme les outils minimalistes tel \textit{Vim} et \textit{Emacs}, ces gestionnaires de fenêtres permettre aussi de bénéficier à l’efficacité des développeurs qui les utilisent grâce aux fonctionnalités adaptées à ceux-ci.

\par
\bigskip
De plus, le tout nouveau protocole de serveur d'affichage \textit{Wayland} est de plus en plus adopté par ces environnements de bureau. Celui-ci est perçu par plusieurs comme un candidat idéal pour remplacer le protocole \textit{X} d'ici quelques années à cause de son architecture optimisée et pour sa meilleure gestion des ressources matérielles.

\par
\bigskip
Dans le cadre de ce projet, nous avons donc décidé de concevoir un gestionnaire de fenêtres utilisant ce nouveau protocole et celui-ci sera écrit avec le langage de programmation \textit{Rust}. Ce langage apporte des fonctionnalités modernes intéressantes en ce qui concerne la gestion mémoire, la concurrence et la gestion de dépendance, tout en gardant une performance rivalisant celle du \textit{C} et \textit{C++}. Il existe peu de gestionnaires de fenêtres utilisant à la fois \textit{Rust} et \textit{Wayland}. Il y en a un en particulier s’appelant \textit{Way-Cooler}\footnote{http://way-cooler.org}, mais selon les auteurs de ce projet, il n’est pas encore assez stable pour être utilisé en “production”.

\par
\bigskip
Notre but sera donc de créer un logiciel que des enthousiastes pourront ultimement utiliser dans leur quotidien tout en nous permettant d’apprendre les rudiments de la programmation de composantes systèmes.

\section{Revue de littérature}
\begin{description}
	\item [Gestionnaire de fenêtre] Un logiciel qui contrôle l’affichage et la
		disposition des fenêtres des applications en exécution.
	\item [Écran] Un écran est un espace de rendu qui est mis à notre
		disposition via un appareil physique (moniteur).
	\item [Espace de travail] Un écran possède une liste d’espaces de travail.
		Un seul espace de travail est affiché à l’écran à la fois et l'utilisateur peut déterminer quel espace de travail à afficher.
	\item [Fenêtre] Une fenêtre est une feuille dans l’arbre de disposition.
		Elle est donc l’espace réservé à l’affichage du rendu d’une application
		en exécution.
	\item [Gestionnaire de disposition de fenêtres]
		\begin{sloppypar}
			Un espace de travail est constitué d’une seule disposition de fenêtres. Celle-ci applique des contraintes d'affichage sur les fenêtres qu'elle contient en ce qui concerne avec la position et la dimension de celles-ci.
		\end{sloppypar}
	\item [Arbre de disposition de fenêtres] Implémentation du gestionnaire de disposition de fenêtres utilisant un arbre enraciné (k-ary tree).
	\item [Noeud de disposition (dans l’arbre de disposition)] Noeud dans
		l’arbre de la disposition. Correspond essentiellement à un conteneur de
		de fenêtres et sous-noeuds.
	\item [Tuile] Correspond à l’espace (ou subdivision) de l’écran réservé à
		une fenêtre.
	\item [Subdivision] Une subdivision représente à la fois un noeud dans
		l’arbre de disposition et un sous-ensemble de l’espace d’affichage de
		l’écran.
	\item [Conteneur de fenêtres] Un conteneur est un noeud dans l’arbre de
		disposition. Il s’agit donc d’une structure de données qui va contenir
		un ensemble de fenêtres ou de
		sous-conteneurs.
	\item [Liaison de touche (Keybinding)] Représente l'association d'une combinaison de touches à une commande de l'application.
	\item [Commande] Fonctionnalité du gestionnaire de fenêtre accessible à l'utilisateur via une combinaison de touche.
	\item [Pointeur] Un appareil physique servant à envoyer des évènements de mouvement au compositeur. Très souvent il s'agit d'une souris, mais pourrait être un écran tactile.
	\item [Curseur] Une image représantant l'emplacement du pointeur dans le compositeur.
	\item [Indicateur d'insertion] Une représentation visuelle de la direction d'insertion relative à la fenêtre active.
	\item [Fenêtre active] Fenêtre possédant le focus, c'est-à-dire qui reçoit les évène-ments des appareils d'entrées (clavier, souris, etc ...).
\end{description}

\section{Installation}
Afin d'installer \textit{Comfy}, la première étape est de s'assurer que l'utilisateur poss-ède toutes les dépendances de \textit{Wlroots}\footnote{https://github.com/swaywm/wlroots}. Ensuite, il faut tout simplement utiliser le fichier \textit{Makefile} de la façon suivante :
\begin{verbatim}
	$ make
	$ sudo make install
\end{verbatim}

\par
Celui-ci s'occupera de compiler et de copier les différents fichiers aux bons emplacements systèmes. Les indications d'installation les plus récentes sont situées dans le fichier \textit{README}.

\section{Manuel d'utilisateur}
Comme tout application \textit{UNIX} qui se respecte, \textit{Comfy} possède un manuel d'utilisateur accessible à l'aide la commande \textit{man}.

\begin{verbatim}
	$ man confywm
\end{verbatim}

\section{Diagrammes du fonctionnement}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{diagramme_du_fonctionnement.png}
	\caption{Représentation de l'état de la disposition de fenêtre}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{diagramme_du_fonctionnement_arbre.png}
	\caption{Arbre résultant}
\end{figure}
\section{Composantes}
\subsection{Configuration}

\par
\bigskip
Afin de donner une meilleure expérience aux utiliseurs de \textit{Comfy}, nous avons décidé de laisser la possibilité de pouvoir personaliser un grand nombre de fonctionnalités à même l'application. Le format des fichiers de configuration utilisera le format \textit{TOML}\footnote{https://github.com/toml-lang/toml}. Ce format est d'ailleurs utilisé pour les fichiers de configuration du langage \textit{Rust}. \textit{TOML} est très similaire au format \textit{YAML} et \textit{JSON} pour la représentation des différents types de données et de la simplicité d'écriture. Par contre, \textit{TOML} porte une plus grande importance à la lisibilité ce qui est un point cruciale pour un fichier de configuration. De plus, il est possible de rajouter des commentaires aux fichiers d'exemple ce qui va nous permettre de bien expliquer les configurations possibles aux utilisateurs. Pour l'instant nous avons les fichiers de configurations suivants:
\begin{itemize}
	\item Un fichier pour les options globales de l'application \textbf{global.toml}
	\item Un fichier pour les raccourcis clavier appelé \textbf{keybings.toml}
	\item Un fichier pour l'apparence de comfy appelé \textbf{theme.toml}
\end{itemize}

\subsubsection{global.toml}
\begin{minipage}{\linewidth}
	\lstinputlisting[label=global-example,title=Exemple d'un fichier
	global.toml]{global.toml}
\end{minipage}

\par
Ce fichier représente les attributs personnalisables associés au comportement général de l'application. Voici la définition des attributs pouvant être personnalisés:
\begin{description}
	\item [pointer\_focus\_type] Détermine de quelle façon l'intéraction du pointeur influence le focus des fenêtres.
\end{description}

\subsubsection{keybindings.toml}
\begin{minipage}{\linewidth}
	\lstinputlisting[label=keybindings-example,title=Exemple d'un fichier
	keybindings.toml]{keybindings.toml}
\end{minipage}

\par
Un paramètre important de ce fichier de configuration est \textit{modkey} qui va servir à définir une sorte de macro utilisable tout au long du fichier. Pour faire référence au \textit{modkey} il faut seulement entrer \textit{\$mod} à l'intérieur d'une chaîne de combinaison de touche et \textit{Comfy} s'occupera de remplacer cette référence à la touche associée précédement. L'utilité du \textit{modkey} est de dédier de façon simple une touche centrale de contrôle pour les commandes de \textit{Comfy}. Une touche parfaite pour le \textit{modkey} serait une touche modificatrice\footnote{https://fr.wikipedia.org/wiki/Touche\_de\_combinaison} comme les touches \textbf{Control}, \textbf{Super} et \textbf{Alt} car celles-ci ne devraient pas avoir un impact sur le fonctionnement des applications sous-jacentes.
\par
\bigskip
Ensuite, nous avons la section \textbf{keybindings}. Cette section sera la partie la plus importante du fichier car c'est elle qui comprend la définition des associations des combinaisons de touches aux commandes. Une entrée de cette section est relativement simple. Le membre gauche de l'association est un ensemble de touches sous la forme d'une chaîne de caractère (entre guillemets) utilisant le caractère séparateur '+'. Malheureusement, la clé en \textit{TOML} (qui est le membre gauche en question) ne peut pas contenir ce symboles, c'est pourquoi nous utilisons la représentation en chaîne de caractère. Ensuite, le membre droit contient deux parties, une commande suivie de ses arguments. Par exemple, à la ligne 4 du fichier d'exemple, nous avons:

\lstinputlisting[frame=none,numbers=none,firstline=4,lastline=4]{keybindings.toml}

La commande serait donc \textbf{exec} et l'argument serait
\textbf{weston-terminal}.

\par
\bigskip
Une chose importante à savoir est que \textit{Comfy} gère les entrées clavier et vérifie si une combinaison de touches se trouve dans le fichier de configuration et l'exécute. Ceci serait problématique le même raccourci serait aussi associé dans une application. Par exemple, associer une commande à la combinaison \textbf{Control+s} ne serait pas une bonne idée puisque celle-ci sera toujours interceptée par \textit{Comfy} avant même de se rendre à l'application.

\subsubsection{theme.toml}
\begin{minipage}{\linewidth}
	\lstinputlisting[label=theme-example,title=Exemple d'un fichier theme.toml]{theme.toml}
\end{minipage}

\par
Ce fichier représente les attributs visuels personnalisables de l'application. Voici la définition des attributs pouvant être personnalisés:
\begin{description}
	\item [border\_size] Détermine l'épaisseur des bordures autour d'une fenêtre à l'intérieur d'une tuile.
	\item [active\_color] Couleur de la bordure autour de la fenêtre active.
	\item [inactive\_color] Couleur de la bordure autour des fenêtres non-actives.
	\item [cursor\_indicator\_color] Couleur du côté de la bordure de la fenêtre active indiquant l'emplacement d'insertion des fenêtres.
	\item [wallpaper\_path] Chemin vers le fichier de l'image qui sera utilisée comme fond d'écran.
\end{description}

\end{document}
